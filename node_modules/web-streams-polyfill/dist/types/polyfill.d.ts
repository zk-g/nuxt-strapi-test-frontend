/// <reference lib="esnext.asynciterable" />

/**
 * A signal object that allows you to communicate with a request and abort it if required
 * via its associated `AbortController` object.
 *
 * @remarks
 *   This interface is compatible with the `AbortSignal` interface defined in TypeScript's DOM types.
 *   It is redefined here, so it can be polyfilled without a DOM, for example with
 *   {@link https://www.npmjs.com/package/abortcontroller-polyfill | abortcontroller-polyfill} in a Node environment.
 */
export declare interface AbortSignal {
    readonly aborted: boolean;
    addEventListener(type: 'abort', listener: () => void): void;
    removeEventListener(type: 'abort', listener: () => void): void;
}

export declare class ByteLengthQueuingStrategy implements QueuingStrategy<ArrayBufferView> {
    constructor(options: QueuingStrategyInit);
    readonly highWaterMark: number;
    readonly size: (chunk: ArrayBufferView) => number;
}

export declare class CountQueuingStrategy implements QueuingStrategy<any> {
    constructor(options: QueuingStrategyInit);
    readonly highWaterMark: number;
    readonly size: (chunk: any) => 1;
}

export declare interface QueuingStrategy<T = any> {
    highWaterMark?: number;
    size?: QueuingStrategySizeCallback<T>;
}

export declare interface QueuingStrategyInit {
    highWaterMark: number;
}

declare type QueuingStrategySizeCallback<T = any> = (chunk: T) => number;

declare type ReadableByteStream = ReadableStream<Uint8Array>;

export declare class ReadableByteStreamController {
    private constructor();
    readonly byobRequest: ReadableStreamBYOBRequest | null;
    readonly desiredSize: number | null;
    close(): void;
    enqueue(chunk: ArrayBufferView): void;
    error(e?: any): void;
}

export declare class ReadableStream<R = any> {
    constructor(underlyingSource: UnderlyingByteSource, strategy?: {
        highWaterMark?: number;
        size?: undefined;
    });
    constructor(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>);
    readonly locked: boolean;
    cancel(reason?: any): Promise<void>;
    getReader({ mode }: {
        mode: 'byob';
    }): ReadableStreamBYOBReader;
    getReader(): ReadableStreamDefaultReader<R>;
    pipeThrough<T>(transform: ReadableWritablePair<T, R>, options?: StreamPipeOptions): ReadableStream<T>;
    pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;
    tee(): [ReadableStream<R>, ReadableStream<R>];
    values(options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator<R>;
    [Symbol.asyncIterator]: (options?: ReadableStreamIteratorOptions) => ReadableStreamAsyncIterator<R>;
}

export declare interface ReadableStreamAsyncIterator<R> extends AsyncIterator<R> {
    next(): Promise<IteratorResult<R>>;
    return(value?: any): Promise<IteratorResult<any>>;
}

export declare class ReadableStreamBYOBReader {
    constructor(stream: ReadableByteStream);
    readonly closed: Promise<void>;
    cancel(reason?: any): Promise<void>;
    read<T extends ArrayBufferView>(view: T): Promise<ReadableStreamBYOBReadResult<T>>;
    releaseLock(): void;
}

export declare type ReadableStreamBYOBReadResult<T extends ArrayBufferView> = {
    done: boolean;
    value: T;
};

export declare class ReadableStreamBYOBRequest {
    private constructor();
    readonly view: ArrayBufferView | null;
    respond(bytesWritten: number): void;
    respondWithNewView(view: ArrayBufferView): void;
}

export declare class ReadableStreamDefaultController<R> {
    private constructor();
    readonly desiredSize: number | null;
    close(): void;
    enqueue(chunk: R): void;
    error(e?: any): void;
}

export declare class ReadableStreamDefaultReader<R = any> {
    constructor(stream: ReadableStream<R>);
    readonly closed: Promise<void>;
    cancel(reason?: any): Promise<void>;
    read(): Promise<ReadableStreamDefaultReadResult<R>>;
    releaseLock(): void;
}

export declare type ReadableStreamDefaultReadResult<T> = {
    done: false;
    value: T;
} | {
    done: true;
    value: undefined;
};

export declare interface ReadableStreamIteratorOptions {
    preventCancel?: boolean;
}

export declare interface ReadableWritablePair<R, W> {
    readable: ReadableStream<R>;
    writable: WritableStream<W>;
}

export declare interface StreamPipeOptions {
    preventAbort?: boolean;
    preventCancel?: boolean;
    preventClose?: boolean;
    signal?: AbortSignal;
}

export declare interface Transformer<I = any, O = any> {
    start?: TransformerStartCallback<O>;
    transform?: TransformerTransformCallback<I, O>;
    flush?: TransformerFlushCallback<O>;
    readableType?: undefined;
    writableType?: undefined;
}

export declare type TransformerFlushCallback<O> = (controller: TransformStreamDefaultController<O>) => void | PromiseLike<void>;

export declare type TransformerStartCallback<O> = (controller: TransformStreamDefaultController<O>) => void | PromiseLike<void>;

export declare type TransformerTransformCallback<I, O> = (chunk: I, controller: TransformStreamDefaultController<O>) => void | PromiseLike<void>;

export declare class TransformStream<I = any, O = any> {
    constructor(transformer?: Transformer<I, O>, writableStrategy?: QueuingStrategy<I>, readableStrategy?: QueuingStrategy<O>);
    readonly readable: ReadableStream<O>;
    readonly writable: WritableStream<I>;
}

export declare class TransformStreamDefaultController<O> {
    private constructor();
    readonly desiredSize: number | null;
    enqueue(chunk: O): void;
    error(reason?: any): void;
    terminate(): void;
}

export declare interface UnderlyingByteSource {
    start?: UnderlyingByteSourceStartCallback;
    pull?: UnderlyingByteSourcePullCallback;
    cancel?: UnderlyingSourceCancelCallback;
    type: 'bytes';
    autoAllocateChunkSize?: number;
}

export declare type UnderlyingByteSourcePullCallback = (controller: ReadableByteStreamController) => void | PromiseLike<void>;

export declare type UnderlyingByteSourceStartCallback = (controller: ReadableByteStreamController) => void | PromiseLike<void>;

export declare interface UnderlyingSink<W = any> {
    start?: UnderlyingSinkStartCallback;
    write?: UnderlyingSinkWriteCallback<W>;
    close?: UnderlyingSinkCloseCallback;
    abort?: UnderlyingSinkAbortCallback;
    type?: undefined;
}

export declare type UnderlyingSinkAbortCallback = (reason: any) => void | PromiseLike<void>;

export declare type UnderlyingSinkCloseCallback = () => void | PromiseLike<void>;

export declare type UnderlyingSinkStartCallback = (controller: WritableStreamDefaultController) => void | PromiseLike<void>;

export declare type UnderlyingSinkWriteCallback<W> = (chunk: W, controller: WritableStreamDefaultController) => void | PromiseLike<void>;

export declare interface UnderlyingSource<R = any> {
    start?: UnderlyingSourceStartCallback<R>;
    pull?: UnderlyingSourcePullCallback<R>;
    cancel?: UnderlyingSourceCancelCallback;
    type?: undefined;
}

export declare type UnderlyingSourceCancelCallback = (reason: any) => void | PromiseLike<void>;

export declare type UnderlyingSourcePullCallback<R> = (controller: ReadableStreamDefaultController<R>) => void | PromiseLike<void>;

export declare type UnderlyingSourceStartCallback<R> = (controller: ReadableStreamDefaultController<R>) => void | PromiseLike<void>;

export declare class WritableStream<W = any> {
    constructor(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>);
    readonly locked: boolean;
    abort(reason?: any): Promise<void>;
    close(): Promise<void>;
    getWriter(): WritableStreamDefaultWriter<W>;
}

export declare class WritableStreamDefaultController<W = any> {
    private constructor();
    error(e?: any): void;
}

export declare class WritableStreamDefaultWriter<W = any> {
    constructor(stream: WritableStream<W>);
    readonly closed: Promise<void>;
    readonly desiredSize: number | null;
    readonly ready: Promise<void>;
    abort(reason?: any): Promise<void>;
    close(): Promise<void>;
    releaseLock(): void;
    write(chunk: W): Promise<void>;
}

export { }
